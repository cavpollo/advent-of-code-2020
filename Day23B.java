package advent;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class Day23B {
    private static int MOVES = 10000000;
    private static int TOTAL_CUPS = 1000000;

    public static void main(String[] args) throws IOException {
        final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));

        System.out.println("Paste the input:");

        final String readLine = bufferedReader.readLine();

        final Instant start = Instant.now();

        Node prevNode = null;
        final List<Node> cups = new ArrayList<>();
        for (final String cupNumber : readLine.trim().split("")) {
            final Node newNode = new Node(Long.parseLong(cupNumber));
            if (prevNode != null) prevNode.setNextNode(newNode);
            cups.add(newNode);
            prevNode = newNode;
        }

        for (final Node cup : cups) {
            final int index = cups.indexOf(new Node(cup.getValue() - 1));
            if (index == -1) continue;
            final Node tempCup = cups.get(index);
            cup.setLowerNumberNode(tempCup);
        }

        final Node nodeNine = cups.get(cups.indexOf(new Node(9L)));
        if (TOTAL_CUPS > 10) {
            // Hack to join the cup list to the autogenerated cups
            final Node nodeTen = new Node(10L, nodeNine);
            prevNode.setNextNode(nodeTen);

            prevNode = nodeTen;
            for (long i = 11; i <= TOTAL_CUPS; i++) {
                final Node newNode = new Node(i, prevNode);
                prevNode.setNextNode(newNode);
                prevNode = newNode;
            }

            // Finish the loop
            prevNode.setNextNode(cups.get(0));
        }

        // Set the lower number node for the NodeOne
        final Node nodeOne = cups.get(cups.indexOf(new Node(1L)));
        if (TOTAL_CUPS > 10) {
            nodeOne.setLowerNumberNode(prevNode);
        } else {
            nodeOne.setLowerNumberNode(nodeNine);
        }

        final int totalCups = cups.size();
        System.out.println("Got " + TOTAL_CUPS + " cups");

//        final Integer highestValue = cups.stream().max(Comparator.naturalOrder()).get();

        Node currentCup = cups.get(0);
        for (int i = 0; i < MOVES; i++) {
//            System.out.println();
//            System.out.println("currentCup " + currentCup);
//            logCups(i, currentCup);

            // Find the next 3 cups
            final Node firstCupNode = currentCup.getNextNode();
            final Node thirdCupNode = firstCupNode.getNextNode().getNextNode();
            Node tempNode = currentCup;
            final List<Long> nextThreeCupValues = new ArrayList<>();
            for (int j = 0; j < 3; j++) {
                tempNode = tempNode.getNextNode();
                nextThreeCupValues.add(tempNode.getValue());
            }
//            System.out.println("next 3 cups " + firstCupNode + " " + firstCupNode.getNextNode() + " " + thirdCupNode);

            // Find the lower cup
            Node lowerNumberCupNode = currentCup.getLowerNumberNode();
//            System.out.println("test lower cup: " + lowerNumberCupNode);
            while (nextThreeCupValues.contains(lowerNumberCupNode.getValue())) {
//                System.out.println(lowerNumberCupNode + " next lower cup: " + lowerNumberCupNode.getLowerNumberNode());
                lowerNumberCupNode = lowerNumberCupNode.getLowerNumberNode();
            }
//            System.out.println("lower cup: " + lowerNumberCupNode);

//            System.out.println(currentCup + " -> " + tempNode.getNextNode());
            currentCup.setNextNode(tempNode.getNextNode()); // Remove the 3 cups from the circular node list

            // Integrate the 3 cups into the circular node list
//            System.out.println(thirdCupNode + " -> " + lowerNumberCupNode.getNextNode());
            thirdCupNode.setNextNode(lowerNumberCupNode.getNextNode());
//            System.out.println(lowerNumberCupNode + " -> " + firstCupNode);
            lowerNumberCupNode.setNextNode(firstCupNode);

            currentCup = currentCup.getNextNode();
        }
//        System.out.print("END: ");
//        logCups(0, nodeOne);

        final Node a = nodeOne.getNextNode();
        final Node b = a.getNextNode();
        System.out.println(a + " " + b);
        final Long product = a.getValue() * b.getValue();

        final Instant finish = Instant.now();
        final long timeElapsed = Duration.between(start, finish).toMillis();

        System.out.println("The product of the next 2 cups is " + product + " in " + timeElapsed + "ms");
    }

    private static void logCups(final int i, final Node currentCup) {
        System.out.print((i + 1) + ": ");
        Node next = currentCup;
        do {
            System.out.print(next + " ");
            next = next.getNextNode();
        } while (next != currentCup);
        System.out.println();
    }

    public static class Node {
        private final Long value;
        private Node lowerNumberNode;
        private Node nextNode;

        public Node(final Long value) {
            this.value = value;
        }

        public Node(final Long value, final Node lowerNumberNode) {
            this.value = value;
            this.lowerNumberNode = lowerNumberNode;
        }

        public Long getValue() {
            return value;
        }

        public Node getLowerNumberNode() {
            return lowerNumberNode;
        }

        public Node getNextNode() {
            return nextNode;
        }

        public void setLowerNumberNode(final Node lowerNumberNode) {
            this.lowerNumberNode = lowerNumberNode;
        }

        public void setNextNode(final Node nextNode) {
            this.nextNode = nextNode;
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            final Node node = (Node) o;
            return value == node.value;
        }

        @Override
        public int hashCode() {
            return Objects.hash(value);
        }

        @Override
        public String toString() {
            return value.toString();
        }
    }
}
